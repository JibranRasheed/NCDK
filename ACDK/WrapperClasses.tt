/*
 * Copyright (C) 2017  Kazuya Ujihara <ujihara.kazuya@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 * All we ask is that proper credit is given for our work, which includes
 * - but is not limited to - adding the above copyright notice to the beginning
 * of your source code files, and to any copyright notice that you may distribute
 * with programs based on this work.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT Any WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".tt.cs" #>

using System;
using System.Runtime.InteropServices;

<#
		const string C_Guid_Interface = "Guid_interface";
		const string C_Guid_class = "Guid_class";
		const string C_class_name = "class_name";
		const string C_implement_interfaces = "implement_interfaces";
		const string C_members = "members";

		var fn = Path.Combine(new FileInfo(this.Host.TemplateFile).Directory.FullName, "Class_Info.txt");
		using (var reader = new StreamReader(fn))
		{
			string[] titleRow = null;
			string m_Guid_Interface = null;
			string m_Guid_class = null;
			string m_class_name = null;
			string m_implement_interfaces = null;
			string m_members = null;
			bool isFirst = true;
			string line;
			while ((line = reader.ReadLine()) != null)
			{
				if (isFirst)
				{
					isFirst = false;
					titleRow = line.Split('\t').Select(n => n.Trim()).ToArray();
					continue;
				}
				string[] cells = new string[5];
				string[] line_split = line.Split('\t').Select(n => n.Trim()).Select(n => (string.IsNullOrEmpty(n) ? null : n)).ToArray();
				for (int i = 0; i < titleRow.Length; i++)
				{
					switch (titleRow[i])
					{
						case C_Guid_Interface:
							m_Guid_Interface = line_split[i];
							break;
						case C_Guid_class:
							m_Guid_class = line_split[i];
							break;
						case C_class_name:
							m_class_name = line_split[i];
							break;
						case C_implement_interfaces:
							m_implement_interfaces = line_split[i];
							break;
						case C_members:
							m_members = line_split[i];
							break;
						default:
							break;
					}
				}
				string[] interfaces = null;
				string[] methods = null;	
				if (m_implement_interfaces != null)
				{
					interfaces = m_implement_interfaces.Split(',').Select(n => n.Trim()).Where(n => !string.IsNullOrEmpty(n)).ToArray();
				}
				if (m_members != null)
				{
					methods = m_members.Split(';').Select(n => n.Trim()).Where(n => !string.IsNullOrEmpty(n)).ToArray();
				}
				CC(m_Guid_Interface, m_Guid_class, m_class_name, interfaces, methods);
			}
		}
/*
CC("136161B3-6FC6-42B9-BAA8-DA181C5BD927", null, "NCDK.IChemObjectBuilder", null, null);
CC("7930EF62-EED8-43B8-B984-D91A87A6D77D", null, "NCDK.IAtomContainer", null, null);
CC("D4CFC8BC-C66E-49CF-B3CC-14F437406955", null, "NCDK.Smiles.SmilesParser", null, new[] { "IAtomContainer ParseSmiles(string smiles)" });
CC("124390C0-5C97-4351-800B-D27A31130D70", null, "NCDK.QSAR.IMolecularDescriptor", null, new[] { "DescriptorValue Calculate(IAtomContainer container)" });
CC("3FF6093F-CAFB-48F3-BAA1-69D5549CC720", null, "NCDK.QSAR.IDescriptor", null, null);
CC("821CF389-3EFC-44BF-9157-7A4ED1ADA6F1", "6B6441F5-3131-4E69-BEE3-B94C809CC163", "NCDK.QSAR.Descriptors.Moleculars.AcidicGroupCountDescriptor",  new[] { "IMolecularDescriptor", }, new[] { "DescriptorValue Calculate(IAtomContainer atomContainer)", });
CC("ECB38294-A140-4566-96D1-66DFB14E050B", null, "NCDK.QSAR.DescriptorValue", null, null);
*/
#>
<#+
	public string WrapGenericTypeName(string genericTypeName)
	{
		return genericTypeName.Replace("<", "_").Replace(">", "");
	}
/*
	public void CC(string guid, string fullName)
	{
		CC(guid, fullName, (string[])null);
	}

	public void CC(string guid, string fullName, string[] methods)
	{
		CC(guid, fullName, methods, (string)null);
	}

	public void CC(string guid, string fullName, string[] methods, string guidClass)
	{
		CC(guid, fullName, methods, (string[])null, guidClass);
	}
*/
	public void CC(string guid, string guidClass, string fullName, string[] interfaces, string[] methods)
	{
		if (methods == null)
			methods = Array.Empty<string>();
		if (interfaces == null)
			interfaces = Array.Empty<string>();

		bool isClass = (guidClass != null);
		string ns;
		string className;
		string interfaceName;
		string wrapperClassName;
		{
			int lastP = fullName.LastIndexOf('.');
			ns = fullName.Substring(0, lastP);
			className = fullName.Substring(lastP + 1);
			interfaceName = (isClass ? "I" : "") + className;
			wrapperClassName = (isClass ? "" : "W_") + className;
		}
#>
namespace ACDK
{
    [Guid("<#=guid#>")]
    [InterfaceType(ComInterfaceType.InterfaceIsDual)]
    public partial interface <#=interfaceName#>
    {
<#+
		int startInex = 0x1001;
		int dispIdIndex;
		dispIdIndex = startInex;
		foreach (var method in methods)
		{
			if (!string.IsNullOrEmpty(method))
			{
				var wrapped = WrapGenericTypeName(method);
#>
		[DispId(0x<#=dispIdIndex.ToString("X4")#>)]
		<#=wrapped#>;
<#+
			}
			dispIdIndex++;
		}
#>
    }

<#+
		if (isClass)
		{
#>
	[Guid("<#=guidClass#>")]
	[ComDefaultInterface(typeof(<#=interfaceName#>))]
<#+
		}
		else
		{
#>
	[ComVisible(false)]
<#+
		}
#>
    public sealed partial class <#=wrapperClassName#>
        : <#=interfaceName#>
<#+
		foreach (var interfac in interfaces)
		{
#>
			, <#=interfac#>
<#+
		}
#>
    {
        <#=fullName#> obj;
        public <#=fullName#> Object => obj;
<#+
		if (guidClass != null)
		{
#>
        public <#=wrapperClassName#>()
			 : this(new <#=fullName#>())
		{
		}
<#+
		}
#>
        public <#=wrapperClassName#>(<#=fullName#> obj)
        {
            this.obj = obj;
        }
<#+
		dispIdIndex = startInex;
		foreach (var method in methods)
		{
			if (!string.IsNullOrEmpty(method))
			{
				if (guidClass != null)
				{
#>
		[DispId(0x<#=dispIdIndex.ToString("X4")#>)]
<#+
				}
#>
		public <#=WrapGenericTypeName(method)#>
			=> <#=MakeWrapperMethod(method)#>;
<#+
			}
			dispIdIndex++;
		}
#>
    }
}
<#+
	}

/**************************************************************************/

		class TypeAndParamerterName
		{
			public string TypeName { get; set; }
			public string ParameterName { get; set; }

			public TypeAndParamerterName(string typeName, string parameterName)
			{
				this.TypeName = typeName;
				this.ParameterName = parameterName;
			}

			public override string ToString()
			{
				return TypeName + " " + ParameterName;
			}
		}
	
		Regex re = new Regex(@"^\b(?<return>\w+[\w\<\>]*)\s+(?<name>\w+)\(\)$", RegexOptions.Compiled);
		Regex re2 = new Regex(@"^\b(?<return>\w+[\w\<\>]*)\s+(?<name>\w+)\((?<typeandparam>\w+[\w\<\>]* \w+)(\, (?<typeandparam>\w+[\w\<\>]* \w+))*\)$", RegexOptions.Compiled);
		HashSet<string> primitiveTypeNames = new HashSet<string>()
			{ "void", "bool", "short", "int", "long", "float", "double", "string", };
		bool IsPrimitive(string typeName) => primitiveTypeNames.Contains(typeName);

		string MakeWrapperMethod(string methodDefine)
		{
			string methodName = null;
			string returnTypeName = null;
			List<TypeAndParamerterName> typeAndParameters = new List<TypeAndParamerterName>();
			string str = methodDefine;
			Match match;
			if ((match = re.Match(str)).Success)
			{
				methodName = match.Groups["name"].Value;
				returnTypeName = match.Groups["return"].Value;
			}
			if ((match = re2.Match(str)).Success)
			{
				methodName = match.Groups["name"].Value;
				returnTypeName = match.Groups["return"].Value;
				foreach (Capture tp in match.Groups["typeandparam"].Captures)
				{
					var tpa = tp.Value.Split(' ');
					typeAndParameters.Add(new TypeAndParamerterName(tpa[0], tpa[1]));
				}
			}
			var  a = MakeMethodWrapper(methodName, returnTypeName, typeAndParameters);
			return a;
		}

		string MakeMethodWrapper(string methodName, string returnTypeName, IEnumerable<TypeAndParamerterName> parameters)
		{
			var ss = new List<string>();
			foreach (var tp in parameters)
			{
				string t = tp.TypeName;
				string wrapped_t = WrapGenericTypeName(t);
				string p = tp.ParameterName;
				string s = null;
				s = !IsPrimitive(t) ? "((W_" + wrapped_t + ")" + p + ").Object" : p;
				ss.Add(s);
			}

			returnTypeName = WrapGenericTypeName(returnTypeName);
			var sb = new StringBuilder();
			if (!IsPrimitive(returnTypeName))
			{
				sb.Append("new ");
				sb.Append("W_" + returnTypeName).Append("(");
			}
			sb.Append("Object.").Append(methodName).Append("(");
			sb.Append(string.Join(", ", ss));
			sb.Append(")");
			if (!IsPrimitive(returnTypeName))
			{
				sb.Append(")");
			}
			return sb.ToString();
		}

#>
