/*
 * Copyright (C) 2017  Kazuya Ujihara <ujihara.kazuya@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 * All we ask is that proper credit is given for our work, which includes
 * - but is not limited to - adding the above copyright notice to the beginning
 * of your source code files, and to any copyright notice that you may distribute
 * with programs based on this work.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT Any WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".tt.cs" #>

using System;
using System.Runtime.InteropServices;

<#
CC("136161B3-6FC6-42B9-BAA8-DA181C5BD927", "NCDK.IChemObjectBuilder");
CC("7930EF62-EED8-43B8-B984-D91A87A6D77D", "NCDK.IAtomContainer");
CC("D4CFC8BC-C66E-49CF-B3CC-14F437406955", "NCDK.Smiles.SmilesParser", new string[] 
	{
		"IAtomContainer ParseSmiles(string smiles)" 
	});
#>

<#+
	public void CC(string guid, string fullName)
	{
		CC(guid, fullName, Array.Empty<string>());
	}

	public void CC(string guid, string fullName, string[] methods)
	{
		int lastP = fullName.LastIndexOf('.');
		string ns = fullName.Substring(0, lastP);
		string className = fullName.Substring(lastP + 1);
		string wrapperInterfaceName = className;
		string wrapperClassName = "W_" + wrapperInterfaceName;
#>
namespace ACDK
{
    [Guid("<#=guid#>")]
    [InterfaceType(ComInterfaceType.InterfaceIsDual)]
    public partial interface <#=wrapperInterfaceName#>
    {
<#+
		int dispIdIndex = 0x1001;
		foreach (var method in methods)
		{
#>
		[DispId(0x<#=dispIdIndex.ToString("X4")#>)]
		<#=method#>;
<#+
			dispIdIndex++;
		}
#>
    }

    [ComVisible(false)]
    public sealed partial class <#=wrapperClassName#>
        : <#=wrapperInterfaceName#>
    {
        <#=ns#>.<#=className#> obj;
        public <#=ns#>.<#=className#> Object => obj;

        public <#=wrapperClassName#>(<#=ns#>.<#=className#> obj)
        {
            this.obj = obj;
        }
<#+
		foreach (var method in methods)
		{
#>
		public <#=method#>
			=> <#=MakeWrapperMethod(method)#>;
<#+
		}
#>
    }
}
<#+
	}

        class TypeAndParamerterName
        {
            public string TypeName { get; set; }
            public string ParameterName { get; set; }

            public TypeAndParamerterName(string typeName, string parameterName)
            {
                this.TypeName = typeName;
                this.ParameterName = parameterName;
            }

            public override string ToString()
            {
                return TypeName + " " + ParameterName;
            }
        }
	
        Regex re = new Regex(@"^\b(?<return>\w+)\s+(?<name>\w+)\(\)$", RegexOptions.Compiled);
        Regex re2 = new Regex(@"^\b(?<return>\w+)\s+(?<name>\w+)\((?<typeandparam>\w+ \w+)(\, (?<typeandparam>\w+ \w+))*\)$", RegexOptions.Compiled);
        HashSet<string> primitiveTypeNames = new HashSet<string>()
			{ "void", "bool", "short", "int", "long", "float", "double", "string", };
        bool IsPrimitive(string typeName) => primitiveTypeNames.Contains(typeName);

        string MakeWrapperMethod(string methodDefine)
        {
            string methodName = null;
            string returnTypeName = null;
            List<TypeAndParamerterName> typeAndParameters = new List<TypeAndParamerterName>();
            string str = methodDefine;
            Match match;
			if ((match = re.Match(str)).Success)
            {
                methodName = match.Groups["name"].Value;
                returnTypeName = match.Groups["return"].Value;
            }
            if ((match = re2.Match(str)).Success)
            {
                methodName = match.Groups["name"].Value;
                returnTypeName = match.Groups["return"].Value;
                foreach (Capture tp in match.Groups["typeandparam"].Captures)
                {
                    var tpa = tp.Value.Split(' ');
                    typeAndParameters.Add(new TypeAndParamerterName(tpa[0], tpa[1]));
                }
            }
			var  a = MakeMethodWrapper(methodName, returnTypeName, typeAndParameters);
			return a;
        }

        string MakeMethodWrapper(string methodName, string returnTypeName, IEnumerable<TypeAndParamerterName> parameters)
        {
            var ss = new List<string>();
            foreach (var tp in parameters)
            {
                string t = tp.TypeName;
                string p = tp.ParameterName;
                string s = null;
                s = !IsPrimitive(t) ? "(W_" + t + ")" + p + ").Object" : p;
                ss.Add(s);
            }

            var sb = new StringBuilder();
            if (!IsPrimitive(returnTypeName))
            {
                sb.Append("new ");
                sb.Append("W_" + returnTypeName).Append("(");
            }
            sb.Append("Object.").Append(methodName).Append("(");
            sb.Append(string.Join(", ", ss));
            sb.Append(")");
            if (!IsPrimitive(returnTypeName))
            {
                sb.Append(")");
            }
            return sb.ToString();
        }

#>
